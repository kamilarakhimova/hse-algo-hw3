# Отчёт

### Итак, наша цель: исследовать, как поведут себя различные алгоритмы поиска кратчайшего пути в неориентированном графе на практике при работе с разными типами и размерами графов.

Оценивать будем по количеству времени выполнения программы (с точностью до наносекунды).

Если какой-либо из графиков хочется рассмотреть ближе, стоит обратиться к папке [Graphs](https://github.com/kamilarakhimova/hse-algo-hw3/blob/main/Graphs), найти по названию и полюбоваться на него там.

Всего алгоритмов было 4, напомню каких:
```
1.    алгоритм Дейкстры 
2.    алгоритм Флойда-Уоршела
3.    алгоритм Форда-Беллмана 
4.    алгоритм поиска A*
```

Также было 3 типа графов:
```
1.    полный (complete) с числом рёбер m = n * (n - 1) // 2
2.    связный (connected) с коэффициентом плотности 0.5 и числом рёбер m = n * (n - 1) // 4
3.    разреженный (sparse), являющийся деревом "бамбук" с числом рёбер m = n - 1
```

> Благодаря усреднению времени выполнения различных алгоритмов, получилось добиться гладких графиков в большей части экспериментов. Однако в некоторых всё-таки имеются заметные выбросы. Полагаю, это связано с нестабильным интернет-соединением в местности, в которой я на данный момент нахожусь. Сильно улучшить ситуацию у меня не получилось, как я ни старалась, поэтому наслаждайтесь тем, что есть, пожалуйста!

Что ж, приступим к думанью. 

Первым делом, проанализируем графики зависимости отдельно по каждому алгоритму.

Далее графики сгруппированы по 4 штуки на одно изображение для наглядности и удобства. 
Они расположены следующим образом:
```
- в верхнем ряду слева график с результатами замеров времени от числа вершин для всех типов графов
- в верхнем ряду справа график с результатами замеров времени от числа рёбер для полных (complete) графов
- в нижнем ряду слева график с результатами замеров времени от числа рёбер для связных (connected) графов
- в нижнем ряду справа график с результатами замеров времени от числа рёбер для разреженных (sparse) графов
```

#### 1. Алгоритм Дейкстры (Dijkstra)

![image](https://github.com/kamilarakhimova/hse-algo-hw3/assets/58568615/f92879bc-87e2-44e1-b349-dbc19d7cf0db)
![image-2](https://github.com/kamilarakhimova/hse-algo-hw3/assets/58568615/0df3f254-f967-4b3c-8186-5a3a716d44c9)


Теоретически асимптотика алгоритма Дейкстры составляет в среднем O(m * log(n)). При этом, в случае работы с полным графом, число рёбер m сводится к O(n^2), а сам алгоритм Дейкстры вследствие стремится к O(n^2 + m) = O(n^2).

На практике видна справедливость теоретической оценки. При увеличении числа вершин в каждом из видов графов, увеличивается и время выполнения алгоритма. С различным числом рёбер ситуация обстоит также, как и с различным количеством вершин: чем меньше рёбер, тем быстрее работает алгоритм. Поэтому, как и ожидалось, лучше всего алгоритм работает с разреженными графами, а хуже всего - с полными. В целом, если рассматривать отдельно графики по числу рёбер, то чётко наблюдается экспоненциальный рост времени работы алгоритма в зависимости от числа вершин. Но, глядя на левую верхнюю картинку, где располагаются все типы графов вместе, можно заметить, что, в сравнении с остальными типами, график зависимости времени работы алгоритма Дейкстры от количества вершин с разреженными графами стремится к линейному O(n), а с полными графами, наоборот, ситуация ухудшается и график стремится к квадратичной оценке O(n^2).

#### 2. Алгоритм Флойда-Уоршела (Floyd-Warshall)

![image-3](https://github.com/kamilarakhimova/hse-algo-hw3/assets/58568615/a1dfd6b0-c5b4-414a-935f-fed911251e81)
![image-4](https://github.com/kamilarakhimova/hse-algo-hw3/assets/58568615/eca12c81-cc6f-434b-9807-28f26a486455)

Тут, в первую очередь, глаз радуется гладким приятным графикам. Хочется любоваться и любоваться ими. Давайте так и сделаем.

Что касается теоретической оценки, асимптотика алгоритма Флойда-Уоршела есть O(n^3).

Результаты экспериментов только подтверждают эту оценку. Действительно, это единственный алгоритм из описываемых, время работы которого почти никак не зависит от количества рёбер в графе. Все типы графов: полный, связный и разреженный идут практически вровень друг с другом при одинаковом числе вершин, отражая график, присущий кубической функции. Графики от числа рёбер подтверждают, что это самое число рёбер не играет существенной роли для времени работы алгоритма.

#### 3. Алгоритм Беллмана-Форда (Bellman-Ford)

![image-5](https://github.com/kamilarakhimova/hse-algo-hw3/assets/58568615/f9df5133-2d06-40d7-9ea9-d616c34ceee5)
![image-6](https://github.com/kamilarakhimova/hse-algo-hw3/assets/58568615/1ba41027-8c7a-4267-8398-054021fbfc39)


В теории алгоритм Беллмана-Форда показывает асимптотику O(n * m), что есть O(n^3) в случае плотного графа и O(n^2) в случае разреженного графа.

И снова практические результаты не конфликтуют с теоретическими оценками. Мы опять видим большую разницу во времени работы алгоритма в зависимости от типа графа, и разница эта отражена очень чётко: разреженные графы показывают себя очень хорошо, связные графы - средне, а полные - хуже всех, двигаясь в сторону кубической асимптотики. Графики от числа рёбер отражают степенную зависимость времени работы от числа рёбер и тоже лишь подтверждают описанную выше ситуацию.

#### 4. Алгоритм поиска A* (A star)

![image-7](https://github.com/kamilarakhimova/hse-algo-hw3/assets/58568615/57ffaeb4-290d-4c5f-83cd-4b58be241850)
![image-8](https://github.com/kamilarakhimova/hse-algo-hw3/assets/58568615/70b4ce72-67ec-40a4-809b-fccfba0a1836)


Алгоритм поиска А* очень похож на алгоритм Дейкстры, так что неудивительно, что ситуация здесь перекликается с той, что была описана в пункте 1. Теоретическая оценка алгоритма А* примерно та же, что и у алгоритма Дейкстры, т.е. составляет в среднем O(m * log(n)).

В общем-то, результаты экспериментов согласны с теорией. С разреженными графами, имеющими меньшее число рёбер, алгоритм работает значительно быстрее, нежели со связными или, ещё хуже, с полными, имеющими наибольшее число рёбер. А так, отдельно сами по себе графики иллюстрируют экспоненциальную сложность алгоритма поиска А*.

Что ещё примечательно, сравнивая значения графиков времени работы алгоритма A* с теми же графиками, но уже для алгоритма Дейкстры, бросается в глаза, что алгоритм А* в основном отрабатывает быстрее Дейкстры и это ожидаемо, так как алгоритм поиска А* как раз предназначен для нахождения пути между двумя вершинами (что и является нашей целью), в то время как алгоритм Дейкстры предназначен для нахождения пути между одной и всеми остальными вершинами, так что логично, что он выполняет больше работы и потому затрачивает больше времени.



Теперь, вторым делом, проанализируем графики зависимости отдельно по каждому типу графов (т.е. все алгоритмы на одном графике).

Далее графики сгруппированы по 2 штуки на одно изображение для наглядности и удобства. 
Они расположены следующим образом:
```
- слева располагается график с результатами замеров времени от числа вершин для всех алгоритмов
- справа разлёгся график с результатами замеров времени от числа рёбер для всех алгоритмов
```

#### 1. Полные графы (complete graphs)

![image-9](https://github.com/kamilarakhimova/hse-algo-hw3/assets/58568615/e1e1bc42-51f4-4949-8483-a0d587c12de0)


При работе с полными графами все алгоритмы стремятся показать свою худшую асимптотику. Можно заметить, что алгоритм Беллмана-Форда почти полностью копирует поведение алгоритма Флойда-Уоршела, стремясь к кубической асимптотике O(n^3), как в графике зависимости времени от числа вершин, так и в графике зависимости времени от числа рёбер. Другое дело алгоритмы Дейкстры и А*, идущие вровень друг с другом. Они показывают себя гораздо лучше, стремясь, тем не менее, к теоретической оценке O(n^2). Графики зависимости от вершин и от рёбер +- идентичны.

#### 2. Связные графы (connected graphs)

![image-10](https://github.com/kamilarakhimova/hse-algo-hw3/assets/58568615/9958d793-881b-441e-93be-d810b07fd315)

Для связных графов ситуация особо не меняется от ситуации, описанной в предыдущем пункте, за исключением поведения алгоритма Беллмана-Форда. Здесь он уже явно отличим от алгоритма Флойда-Уоршела и больше стремится к алгоритмам Дейкстры и А*. Последние всё также отрабатывают быстрее всех, практически неотличимо друг от друга. Графики зависимости от вершин и от рёбер +- идентичны.

#### 3. Разреженные графы (sparse graphs)

![image-11](https://github.com/kamilarakhimova/hse-algo-hw3/assets/58568615/093b222d-a960-4c6c-adda-7ff75bb76f36)

Здесь, наконец-то, Беллман-Форд показывает себя во всей красе, смешавшись с функциями зависимостей алгоритмов Дейкстры и поиска А*. Один только алгоритм Флойда-Уоршела совсем не поменялся, стабильно отражая кубическую асимптотику O(n^3). Графики зависимости от вершин и от рёбер +- идентичны.

### Вывод:

Подведём итоги исследования. Не существует однозначно лучшего алгоритма для поиска поиска кратчайшего пути в неориентированном графе. Выбирать какой конкретно использовать в конкретном случае следует исходя из множества факторов. Например, таких, как тип поиска пути (от одной вершины к другой/от одной ко всем остальным или от всех ко всем), тип графа и количество рёбер в нём (полный/разреженный), количество вершин в графе и пр. 

В ходе моей работы оказалось, что для поиска пути от одной вершины к другой лучше всего брать алгоритм поиска А*, независимо от типа графа. Это ожидаемо, так как все остальные алгоритмы предназначены для достижения более сложных целей: нахождения путей от одной вершины ко всем остальным, либо нахождения путей от всех вершин ко всем.

При использовании алгоритмов Дейкстры/A*/Беллмана-Форда, мои исследования показали, что наиболее оптимально брать разреженные графы, для них эти алгоритмы показывают наилучшую асимптотику, а наименее оптимально работать с полными графами, для них асимптотика, наоборот, наихудшая.

Что касается алгоритма Флойда-Уоршела, он работает примерно одинаково с любым типом графов и всегда стремится показать всем свою кубическую асимптотику O(n^3).

### Конец!
