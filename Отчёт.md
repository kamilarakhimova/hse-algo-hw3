# Отчёт

### Итак, наша цель: исследовать, как поведут себя различные алгоритмы поиска кратчайшего пути в неориентированном графе на практике при работе с разными типами и размерами графов.

Оценивать будем по количеству времени выполнения программы (с точностью до наносекунды).

Если какой-либо из графиков хочется рассмотреть ближе, стоит обратиться к папке [Graphs](https://github.com/kamilarakhimova/hse-algo-hw3/blob/main/Graphs), найти по названию и полюбоваться на него там.

Всего алгоритмов было 4, напомню каких:
```
1.    алгоритм Дейкстры    ✔ 
2.    алгоритм Флойда-Уоршела    ✔ 
3.    алгоритм Форда-Беллмана    ✔ 
4.    алгоритм поиска A*    ✔
```

Также было 3 типа графов:
```
1.    полный (complete) с числом рёбер m = n * (n - 1) // 2
2.    связный (connected) с коэффициентом плотности 0.5 и числом рёбер m = n * (n - 1) // 4
3.    разреженный (sparse), являющийся деревом "бамбук" с числом рёбер m = n - 1
```

> Благодаря усреднению времени выполнения поиска различных алгоритмов, получилось добиться гладких графиков в большей части экспериментов. Однако в некоторых всё-таки имеются заметные выбросы. Полагаю, это связано с нестабильным интернет-подключением в местности, в которой я на данный момент нахожусь. Сильно улучшить ситуацию у меня не получилось, как я ни старалась, поэтому наслаждайтесь тем, что есть, пожалуйста!

Что ж, приступим к думанью. 

Первым делом, проанализируем графики зависимости отдельно по каждому алгоритму.

Далее графики сгруппированы по 4 штуки на одно изображение для наглядности и удобства. 
Они расположены следующим образом:
```
- в верхнем ряду слева график с результатами замеров времени от числа вершин для всех типов графов
- в верхнем ряду справа график с результатами замеров времени от числа рёбер для полных (complete) графов
- в нижнем ряду слева график с результатами замеров времени от числа рёбер для связных (connected) графов
- в нижнем ряду справа график с результатами замеров времени от числа рёбер для разреженных (sparse) графов
```

#### 1. Алгоритм Дейкстры (Dijkstra)

![image](https://github.com/kamilarakhimova/hse-algo-hw3/assets/58568615/e8196554-d46e-4b92-9640-9492dbf269f1)
![image-2](https://github.com/kamilarakhimova/hse-algo-hw3/assets/58568615/b5213be0-8ef5-4f71-8453-2c9bee76a8a7)




На таком небольшом размере текста прослеживается следующая тенденция, не зависящая от количества символов подстановки: лучше всего показывает себя наивный алгоритм, а хуже всего - алгоритм Бойера-Мура-Хорспула (далее БМХ). Различные реализации алгоритма КМП ведут себя более менее одинаково, по скорости работы приближаясь к наивному алгоритму, хоть и практически не обгоняя его. Также можно заметить, что алгоритм БМХ растёт экспоненциально параллельно с ростом размера шаблона, в то время как на остальные алгоритмы этот факт не играет почти никакой роли.
Что касается непосредственно замеров времени: абсолютно для каждого алгоритма при отсутствии символов подстановки в тексте замеры оказываются значительно ниже, нежели при их присутствии.

#### 2. Алгоритм Флойда-Уоршела (Floyd-Warshall)

![image-3](https://github.com/kamilarakhimova/hse-algo-hw3/assets/58568615/357d740e-be1f-4e1b-95fc-faf909801451)
![image-4](https://github.com/kamilarakhimova/hse-algo-hw3/assets/58568615/24733081-a48f-448f-8862-bf4f1309c2b0)




Здесь начинается интересное. Картина резко изменилась, теперь в лидеры выбился алгоритм БМХ. Наивный алгоритм всё ещё показывает себя лучше алгоритмов КМП, но так или иначе все они значительно уступают по времени работы алгоритму БМХ. При этом существенных различий в работе различных модификаций алгоритма КМП всё ещё не видно.
Теперь алгоритм БМХ ведёт себя гораздо спокойнее, не особо завися от роста размера строки-шаблона, как было ранее. Ситуация с замерами времени при разном количестве символов подстановки повторяется.

#### 3. Алгоритм Беллмана-Форда (Bellman-Ford)

![image-5](https://github.com/kamilarakhimova/hse-algo-hw3/assets/58568615/d9aaedd0-ea27-4c3d-a3b1-5b6848c4d912)
![image-6](https://github.com/kamilarakhimova/hse-algo-hw3/assets/58568615/075de9a4-5e42-4989-a29a-62a571fd9818)



В данных обстоятельствах ситуация не слишком отличается от ситуации, описанной в пункте 1. Всё также лучшим оказывается наивный алгоритм, а худшим вариантом - алгоритм БМХ. От изменения количества символов в алфавите ничего особо не поменялось по количеству потраченного на работу времени на практике.

#### 4. Алгоритм поиска A* (A star)

![image-7](https://github.com/kamilarakhimova/hse-algo-hw3/assets/58568615/102a25d3-bdad-4c0f-bb22-ddbd5d997860)
![image-8](https://github.com/kamilarakhimova/hse-algo-hw3/assets/58568615/c521c4b5-5863-406c-a6b6-2275890a6f17)


А тут ситуация перекликается с той, что была описана в пункте 2. Опять поменялось положение игроков: БМХ показывает себя сильно лучше остальных. Однако появляется ещё один интересный момент: теперь более чётко видна разница между реализациями алгоритма КМП и наивного алгоритма. Второй показывает себя заметно приятнее первого.





Теперь, вторым делом, проанализируем графики зависимости отдельно по каждому типу графов (т.е. все алгоритмы на одном графике).

Далее графики сгруппированы по 2 штуки на одно изображение для наглядности и удобства. 
Они расположены следующим образом:
```
- слева располагается график с результатами замеров времени от числа вершин для всех алгоритмов
- справа разлёгся график с результатами замеров времени от числа рёбер для всех алгоритмов
```

#### 1. Полные графы (complete graphs)

![image-9](https://github.com/kamilarakhimova/hse-algo-hw3/assets/58568615/9632e6ab-dc19-42cb-a403-d5e83934795d)



#### 2. Связные графы (connected graphs)

![image-10](https://github.com/kamilarakhimova/hse-algo-hw3/assets/58568615/dc489f3c-4134-47f1-aab2-d22d1c56ff4f)


#### 3. Разреженные графы (sparse graphs)

![image-11](https://github.com/kamilarakhimova/hse-algo-hw3/assets/58568615/5ee8240d-dd21-431b-af0e-4a7248f04543)



### Вывод:

-тут пока не то-

Подведём итоги исследования. Не существует однозначно лучшего алгоритма для поиска подстроки-шаблона в тексте. Выбирать какой конкретно использовать в конкретном случае следует исходя из множества факторов. Например, таких, как размер входных данных, случайность генерации данных, мощность алфавита, необходимость работы в реальном времени, требуемые затраты на использование дополнительной памяти и пр. 

В ходе моей работы оказалось, что при небольшом размере текста (10000 символов) наивный алгоритм показывает себя лучше остальных, более изощрённых алгоритмов. Зато при увеличении размера текста (100000 символов) значительно приятнее других показывает себя алгоритм Бойера-Мура-Хорспула. А различные модификации алгоритма КМП (со стандартными/уточненными гранями) всегда выдают примерно схожие друг с другом результаты и практически всегда остаются в стабильных "середнячках".
При этом ни мощность алфавита, ни количество символов подстановки особо не влияют на расклад сил.

### Конец!
